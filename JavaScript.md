## 	Image



`Image()` 将会创建一个新的 `HTMLImageElement` 的实例，它等价于 `document.createElement("img")`

有两个可选参数，分别是高度和宽度，语法 `Image(width, height)`



Image 事件：

- onload
- onerror
- onabort

Image 常用属性：

- alt
- complete
- height
- width
- id
- name
- src
- classname
- title



complete 属性：`HTMLImageElement` 的一个属性，用来判断图片是否加载完成，完成返回 true。不论图片是否有缓存、src 是否有值、图片加载成功或失败，只要流程走完就返回 true，有点奇怪。

onload 事件：`Image` 对象的回调，远程加载图片才会触发，本地不会。当图片加载完成并且成功后，会执行 `onload` 绑定的函数。



为什么 `onload` 事件要在 `src` 设置之前调用？

当 `image` 的 src 改变时，浏览器会自动去加载 src 资源，这个过程是异步的。知道图片加载完成，触发 onload，js 才会回来执行 onload 的内容

假设有一个场景，你的网速很快或者图片内存很小，就是图片加载的速度快于 JS 执行代码的速度，这时如果 onload 是放在 src 之后，浏览器还没读取到 onload 内容，图片已经加载完成了，这就会导致 onload 事件赋值在图片加载之后，所以 onload 里面的内容并不会执行。



缓存

优点：通过 `new Image()` 创建图片不会增加 DOM 渲染时间，





# 数组



## 数组方法



### reduce

一、语法

~~~js
arr.reduce(function(prev,cur,index,arr){
}, init);
~~~

参数说明：

- arr：原数组
- prev：上一次回调返回值，或初始值 init
- cur：当前处理的元素
- index：当前处理数组元素的索引，有 init 则索引为 0，否则为 1
- init：pre 初始值

二、使用场景

1. 求数组之和

~~~js
var sum = arr.reduce((prev, cur) => {
    return prev + cur;
}, 0);
// 有条件的求和
var sum = arr.reduce((prev, cur) => {
    return prev + (cur.isNum ? cur : 0);
}, 0);
~~~

2. 求数组最大值

~~~js
var max = arr.reduce((prev, cur) => {
    return Math.max(prev,cur);
});
~~~

3. 数组去重

~~~js
var newArr = arr.reduce((prev, cur) => {
    prev.indexOf(cur) === -1 && prev.push(cur);
    return prev;
}, []);
~~~



# 作用域和闭包



## 作用域是什么

### 编译原理



程序中一段源代码在执行之前一般会经历3个步骤

1. 分词/词法分析：分词即分解成代码块（词法单元），词法分析
2. 解析/语法分析：解析成「抽象语法树」
3. 代码生成：将 AST 转换成可执行的代码



### 理解作用域



3个角色：

- 引擎：负责整个 JavaScript 的编译工作
- 编译器：负责词法分析和代码生成
- 作用域：负责收集所有声明过的变量，提供查询



变量的赋值操作-2个动作

1. 如果该变量之前没有声明过，**编译器**会在当前**作用域**声明一个变量（声明提前）
2. 运行时**引擎**会在作用域中查找该变量，能找到就进行赋值



编译器术语：LHS 和 RHS 查询

LHS：变量出现在赋值操作的左侧，如 `a = 2`

RHS：变量在赋值操作的右侧，寻找源值，获取某个值，如 `console.log(a)`，需执行查找 `a` 的值



### 作用域嵌套



在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到变量，或抵达到最外层变量为止



### 异常行为



非严格模式下，当执行 LHS 查询时，如果在最外层作用域（全局作用域）中也找不到目标变量时，全局作用域中会创建一个相同名称的变量，返回给引擎；严格模式下，禁止自动或隐式地创建全局变量，执行上段操作引擎会抛出异常，为 `ReferenceError`

如果 RHS 查询找到一个变量，但你对该变量进行不合理的操作，如调用一个非函数类型的值，或引用 `null` 或 `undefined` 中的属性，会抛出另一种异常，`TypeError`

`ReferenceError` 表示同作用域判别失败，而 `TypeError` 表示作用域判别成功了，但是对结果的操作是非法或不合理的

非严格模式下，RHS 引用不成功会导致抛出 `ReferenceError` 异常，LHS 引用会自动隐式地创建一个全局变量，不会报错，除非在严格模式下，会抛出 `ReferenceError` 异常



## 词法作用域



### 词法阶段



词法阶段：编译器的第一次工作阶段，在此过程中，编译器会将咱们编写的代码词法化，即对源代码中的字符进行检查，赋予单词含义

词法作用域是定义在词法阶段的作用域，即由变量和块作用域的位置决定的。编译器在词法分析阶段基本能够知道所有标识符的声明位置以及声明方式，从而实现在执行过程中快速查找

作用域由内往外逐级查找，会在找到第一个匹配的标识符后停止，如果多层嵌套的作用域中出现同名标识符，会出现「遮蔽效应」，即后面的变量会覆盖前面的同名变量

全局变量会自动成为全局对象（window对象）的属性，通过 `window.xx` 可以访问那些被同名变量遮蔽掉的全局变量



### 欺骗词法



`eval(..)` 通常被用来执行动态创建的代码，会修改所处的词法作用域，但在严格模式下无法修改

~~~js
function foo(str) {
  // "use strict";
  eval(str);
  console.log(a); // 2
}
foo("var a = 2");
~~~

`new Function([arg1, arg2...], functionBody)` 行为类似，也可以在程序中动态生成代码，但要避免使用

`with` 可以将一个对象处理为一个完全隔离的词法作用域，对象的所有属性也会被定义为在该词法作用域中的词法标识符（变量）

`eval(..)` 函数如果接受了含有声明的代码，就会修改所处的词法作用域；`with` 声明是根据你传递给它的对象凭空创建了一个全新的词法作用域



### 动态作用域

动态作用域并不会关心函数和作用域是如何声明的，只会关心从何处调用。也就是说，作用域链是基于调用栈，而不是代码中的作用域嵌套

词法作用域和动态作用域的区别：词法作用域是在定义的时候确定的，而动态作用域是在运行时确定的。（this 也是）



### 副作用-性能

不利于性能优化，JavaScript 引擎会在编译阶段进行性能优化，如提前确认所有的变量和函数的定义位置，方便在代码执行过程中快速找到，而 `eval` 和 `with` 的使用破坏了这一规则，如果大量使用会导致代码运行速度变得很慢



## 函数作用域和块作用域



### 函数中的作用域

属于这个函数的全部变量都可以在整个函数的范围内使用、复用



### 隐藏内部实现

最小授权原则，即最小限度地暴露必要的内容，防止外部以非预期的方式使用，除此之外，还可以避免同名标识符的冲突



规避冲突方法

1. 全局命名空间：当程序加载过多的第三方库时，这些库通常会在全局作用中声明一个对象（命名空间），把暴露给外部的功能变为该对象的属性，而不是直接暴露在全局作用域中
2. 模块管理：利用模块管理器，通过管理器的机制将库的标识符显式导入到另一个特定的作用域中



### 函数作用域



**函数声明和表达式**

如果 `function` 是声明中的第一个词，那它就是一个函数声明，否则是一个表达式 `(function...`。

函数声明和表达式之间最重要的区别是它们的名称标识符会绑定在何处。

~~~js
// 函数表达式，foo绑定在自身"..."的作用域中，而不在所处的作用域中，所以外部作用域访问不到 foo
(function foo() {...})()
                 
// 函数声明，foo绑定在所处作用域中
function foo() {}             
~~~



**具名和匿名**

没有名称标识符的函数为匿名函数，缺点：无名调试困难、自身难以引用、代码可读性差，**始终给函数表达式命名最佳**

函数声明不能省略函数名



立即执行函数表达式 IIFE

~~~js
(function foo(){
    // do something
})()
~~~



较为普遍的进阶用法：把它们当作函数调用并传递参数进去

~~~js
var a = 2;
(function IIFE( global ) {
	var a = 3;
    console.log( a ); // 3
    console.log( global.a ); // 2
})( window );
console.log( a ); // 2
~~~



倒置代码的运行顺序，UMD 中常用

~~~js
var a = 2;
(function IIFE( def ) {
	def( window );
})(function def( global ) {
    var a = 3;
    console.log( a ); // 3
    console.log( global.a ); // 2
});
~~~



### 块作用域

块作用域指的是变量和函数不仅可以属于所处的作用域， 也可以属于某个代码块



`var` 声明的缺陷，如以下代码，`i` 会被绑定到外部作用域（函数或全局）

~~~js
for (var i=0; i<10; i++) {}
~~~



属于块作用域

`with`：块作用域的一种形式

`try/catch`：`catch` 分句会创建一个块级作用域，仅在 `catch` 内有效



#### let

将 `let` 变量附加到已经存在的作用域上的行为是隐式的；使用 `{...}` 来显式创建一个块，可让变量的附属关系变得清晰。

`let` 的声明不会在块级作用域中进行提升，声明语句运行之前，声明并不存在



作用

1.垃圾收集：块作用域对内存垃圾的回收机制更加友好

~~~js
function process() {}
{
    // 后续不会再用到这个块 可以销毁了
    let data = {}
    process(data)
}
...
~~~

2.let 循环



ES6 之前块作用域的替代方案：使用 `catch`，因为 `catch` 分句具有块作用域 



#### const 

同样是用来创建块作用域，但和 `let` 的区别是它的值是固定的，任何试图改变 `const` 定义的值都会引起错误



## 提升



### 编译器

编译阶段的一部分工作是找到所有声明，并用合适的作用域将它们关联起来，提供变量的查询操作

提升：变量和函数的声明位置被「移动」到代码最上面。无论作用域中声明在哪，都会在代码被执行之前进行提升处理

先有声明后有赋值，只有声明本身会被提升，赋值和其他操作逻辑会保留在原地



函数声明会被提升，但函数表达式不会被提升

~~~js
foo()
function foo(){}
// 提升 等价于
function foo(){}
foo()

// 函数表达式不会被提升
foo() // TypeError: foo is not a function
var foo = function() {}
// 等价于
var foo;
foo();
foo = function() {}
~~~



### 函数优先

函数声明和变量声明都会被提升，需注意的是，函数首先被提升，然后才是变量

~~~js
foo()
var foo;
function foo() { console.log(1) }
foo = function() { console.log(2) }
// input: 1
~~~



普通块作用域中的函数声明通常会被提升到作用域的顶部，**并且不受条件判断影响**，所以要避免在块作用域内部声明函数

~~~js
foo(); // 2
if (true) { 
	function foo() { console.log(1) }
} else {
    function foo() { console.log(2) } // 声明提升并覆盖前面的 foo 声明
}
~~~



## 闭包



**当函数在它定义时所处的作用域之外的地方，被调用了，该函数就会使用闭包**

如果将函数作为第一级参数值类型，到处传递，也会产生闭包



### 循环和闭包

~~~js
for (var i=1; i<=5; i++) {
    setTimeout( function timer() {
    	console.log( i );
    }, i*1000 );
}
// 预期：输出 1-5，每秒 1 个；
// 实际：输出是 5 个 6，每秒 1 次
~~~



虽然在每次循环中，`setTimeout` 函数是在各个迭代中分别定义的，但它们都处在同一个共享的全局作用域中，它们都共享一个 `i` ，解决方法是利用闭包作用域或创造新的作用域

~~~js
// 创建新的作用域
for (var i=1; i<=5; i++) {
    (function(j) {
    	setTimeout( function timer() {
    		console.log( j );
    	}, j*1000 );
    })( i );
}
~~~



或者使用**块作用域**，for 循环头部的 let 声明会有一个特殊的行为。就是 let 定义的变量在循环过程中，每次迭代都会重新声明。随后每个迭代都会使用上一个迭代结束时的值来初始化这个变量

块作用域和闭包联手，便可天下无敌



### 模块

函数也是对象，所以函数也可以拥有属性。



模块模式需要具备两个条件

1. 要有存在外部作用域的封闭函数，该函数至少被调用一次（每次调用会创建一个新的模块实例）
2. 封闭函数至少返回一个内部函数，这样内部函数才能在私有作用域中形成闭包，并可访问或修改私有的状态



函数返回的对象属如果没有闭包函数，只有数据属性，这便不是闭包。

在模块实例的内部保留对公共 API 的引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值

~~~js
var foo = (function CoolModule(id) {
    function change() {
    // 修改公共 API
    	publicAPI.identify = identify2;
    }
    function identify1() {
    	console.log( id );
    }
    function identify2() {
    	console.log( id.toUpperCase() );
    }
    var publicAPI = {
        change: change,
        identify: identify1
    };
    return publicAPI;
})( "foo module" );
foo.identify(); // foo module
foo.change();
foo.identify(); // FOO MODULE
~~~



### this



~~~js
var obj = {
    id: "111",
    	cool: function coolFn() {
    	console.log( this.id );
    }
};
var id = "222"
obj.cool(); // 111
setTimeout( obj.cool, 100 ); // 222
~~~

**注意**：`setTimeout` 函数是在全局作用域中执行的，因此 `setTimeout` 执行函数的 `this` 永远指向 `window`



箭头函数在涉及 this 绑定时的行为和普通函数是不一样的，它放弃了普通函数 this 的绑定规则，取而代之的是当前的词法作用域覆盖了 this 本身的值



# this和对象



## this



### **this 的误解**

this 既不指向函数自身也不指向函数的词法作用域

this 是运行时绑定的，而不是在编写时，因此它的上下文取决于函数调用时的各种条件



### this是什么

this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。当一个函数被调用时，会创建一个活动记录，这个记录包含函数在哪里被调用（调用栈）、函数调用方法、传入的参数信息，this 就是记录其中的一个属性



### this调用位置

函数被调用的位置，不是声明的位置



### this 绑定规则



#### 默认绑定

当函数不使用任何修饰，里面的 this 就使用默认绑定，此时 this 的绑定规则取决于调用位置,如指向 `window`。如果使用严格模式，全局对象就无法使用默认绑定



#### 隐式绑定

~~~js
function foo() {
	console.log( this.a );
}
obj2 = { a: 42, foo }
obj1.obj2.foo(); // 42
~~~

函数引用有上下文对象时，隐式绑定规则会把函数中的 this 绑定到该上下文对象，对象引用链中只有最后一层会影响调用位置



隐式丢失

~~~js
var baz = obj2.foo;
var a = 123;
baz(); // 123
~~~



#### 显式绑定

`foo.call(...) | foo.apply(...)` 

仍无法解决绑定丢失的问题



硬绑定

1. 创建一个包裹函数，并传入相关参数

~~~js
var bar = function() {
    return foo.apply( obj, arguments );
};
var bar = function() {
    return foo.call( obj );
};
~~~



2. 利用 `bind` 创建辅助函数，`bind` 会返回一个新函数

~~~js
var bar = bind( foo, obj )
~~~



API 调用上下文

JS 许多新的内置函数，都提供了一 个可选的参数，通常被称为上下文，其作用和 `bind(..)` 一样，确保你的回调函数使用指定的 `this`

~~~js
[1, 2, 3].forEach( foo, obj );
~~~



#### new 绑定



使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作

1. 创建（或者说构造）一个全新的对象。 
2. 这个新对象会被执行 [[ 原型 ]] 连接。 
3. 这个新对象会绑定到函数调用的 this。 
4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象

如：

~~~js
function foo(a) {
    this.a = a;
}
var bar = new foo(2);
console.log( bar.a ); // 2
~~~

1. 创建一个全新对象 `bar`
2. 新对象链接到原型 `foo`
3. 新对象绑定函数调用的 `this`
4. 没有返回其他东西，则自动返回 `this` 对象



#### this绑定优先级

new 绑定 > 显式绑定 > 隐式绑定



#### this的4种规则

- 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 `var bar = new foo()` 
- 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 `var bar = foo.call(obj2)`
- 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 `var bar = obj1.foo()`
- 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 `var bar = foo()`



### 箭头函数的this

- 箭头函数不适用普通函数 this 的 4 种规则，而是根据外层作用域来决定 this
- 箭头函数的绑定无法被修改，new 也不行，而是根据当前的词法作用域来决定 this
- 箭头函数会继承外层函数调用的 this 绑定



### 总结

有些调用可能在无意中使用默认绑定规则。如果想安全地忽略 this 绑定，可以使用一个 DMZ 对象，比如 `ø = Object.create(null)`，以保护全局对象



## 对象



### 语法

- 声明形式：`var obj = {}`
- 构造形式：`var obj = new Object()`



区别：在文字声明中可添加多个键值对，但是在构造函数中只能一个一个添加



### 类型



6 种主要类型：`string` 、`number`、 `boolean`、 `null`、 `undefined`、 `object`

简单基本类型本身不是对象，`null` 被当作对象类型是语言的一种 bug，因为 `null` 是一种基本类型

「JavaScript 中万物皆对象」，这种说法是错误的，它只是基本类型中的一种

函数是对象的一种子类型，可以理解为「可调用的对象」

数组也是对象的一种类型，它有一些额外行为



#### 内置对象

这些内置函数可以当作构造函数

内置对象：String Number Boolean Object Function Array Date RegExp Error

我们一般是通过字面量的形式去声明字符串，js 引擎在适当的时机会自动把字面量转换成 String 对象，所以你可以访问字符串的属性

`null ` 和 `undefined` 没有对应的构造形式，而 `Date` 只有构造，没有文字形式



#### 内容

对象的内容就是存储在对象里的属性

在对象中，属性名必须是字符串形式，如果你用字符串以外的值作为属性，对象会先把它转换成一个字符串，数字也是如此

我们通过 `obj[x+y]` 来实现通过表达式计算属性名

属性访问返回的函数和其他函数是一样的，函数并不会属于对象，它们两者顶多只能算是间接关系（this）

数组也是对象，它使用下标/值对来表示

对象的复制：浅拷贝-`Object.assign()`  深拷贝-`JSON序列化`-适用于部分情况



##### **属性描述符**

获取对象某个属性的描述符：`Object.getOwnPropertyDescriptor(obj, key)`

- writeable：决定是否可以修改属性的值
- configurable：属性是否可配置，设置为 false 是单向操作，并且还禁止被删除
- enumerable：是否可枚举，



##### 不变性

对象常量不变：设置 `writable: false` 和 `configuable: false` 使属性不可修改、删除

禁止拓展：禁止添加新属性并且保留已有属性 `Object.preventExtensions( myObject );`

密封：禁止拓展，并且将已有属性设置`configuable: false`，即 `Object.seal()` 

冻结：级别最高的不可变性，密封后，并关闭属性的访问权 `writable: false`，即 `Object.assign()`



##### Getter 和 Setter

通常来说，这两兄弟是一起出现的

对象的属性不一定有值，它可能是具备 getter/setter 的访问描述符

属性可以设置为可枚举或者不可枚举，这决定了它们是否会出现在 `for..in` 循环中



##### 存在性

- `in` 操作符会检查属性是否在于对象及其对象的原型链中
- `hasOwnProperty` 是检查属性是否存在于对象中，并不会检查其原型链



#### 遍历

遍历对象的属性时，属性的顺序是不确定的

`for..of` 会寻找内置或者自定义的 @@iterator 对象并调用它的 `next()` 方法来遍历数据值

普通的对象没有内置的 @@iterator，需要自己定义



## 混合对象



类被实例化时，它的行为会被复制到实例中，类被继承时，行为会被复制到子类中

多态并不是子类复制父类，本质上引用的是复制的结果

JavaScript 并不会向类那样自动创建副本

混入模式可以用来模拟类的复制行为，但无法完全模拟类的复制行为



## 原型



